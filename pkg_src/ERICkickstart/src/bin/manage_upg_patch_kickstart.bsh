#!/bin/bash
# ********************************************************************
# Ericsson Radio Systems AB                                     SCRIPT
# ********************************************************************
#
#
# (c) Ericsson Radio Systems AB 2018 - All rights reserved.
#
# The copyright to the computer program(s) herein is the property
# of Ericsson Radio Systems AB, Sweden. The programs may be used
# and/or copied only with the written permission from Ericsson Radio
# Systems AB or in accordance with the terms and conditions stipulated
# in the agreement/contract under which the program(s) have been
# supplied.
#
# ********************************************************************
# Name    : manage_upg_patch_kickstart.bsh
# Date    : 31/07/2018
# Revision: A.1
# Purpose : This script will set up the kickstart area for Patch
#
# Usage   : manage_upg_patch_kickstart.bsh
#
# ********************************************************************
#
#   Command Section
#
# ********************************************************************
AWK=/usr/bin/awk
BASENAME=/usr/bin/basename
BC=/usr/bin/bc
CAT=/usr/bin/cat
CHMOD=/usr/bin/chmod
CHOWN=/usr/bin/chown
CLEAR=/usr/bin/clear
CMP=/usr/bin/cmp
CP=/usr/bin/cp
CPIO=/usr/bin/cpio
DATE=/usr/bin/date
DF=/usr/bin/df
DIRNAME=/usr/bin/dirname
DOMAINNAME=/usr/bin/domainname
ECHO=/usr/bin/echo
EGREP=/usr/bin/egrep
EJECT=/usr/bin/eject
ENV=/usr/bin/env
EXPR=/usr/bin/expr
FIND=/usr/bin/find
FORMAT=/usr/sbin/format
FUSER=/usr/sbin/fuser
EGREP=/usr/sfw/bin/gegrep
GETENT=/usr/bin/getent
GREP=/usr/bin/grep
GROUPADD=/usr/sbin/groupadd
GTAR=/usr/sfw/bin/gtar
GZCAT=/usr/bin/gzcat
HEAD=/usr/bin/head
HOSTNAME=/usr/bin/hostname
ID=/usr/bin/id
IFCONFIG=/usr/sbin/ifconfig
INIT=/usr/sbin/init
LS=/usr/bin/ls
MKDIR=/usr/bin/mkdir
MKISOFS=/usr/bin/mkisofs
MORE=/usr/bin/more
MV=/usr/bin/mv
AWK=/usr/bin/n$AWK
NETSTAT=/usr/bin/netstat
PG=/usr/bin/pg
PGREP=/usr/bin/pgrep
PING=/usr/sbin/ping
PRINTF=/usr/bin/printf
PRTCONF=/usr/sbin/prtconf
PWD=/usr/bin/pwd
REBOOT=/usr/sbin/reboot
RM=/usr/bin/rm
RMDIR=/usr/bin/rmdir
RCP=/usr/bin/rcp
ROUTE=/usr/sbin/route
RSH=/usr/bin/rsh
SCP=/usr/bin/scp
SED=/usr/bin/sed
SHARE=/usr/sbin/share
SLEEP=/usr/bin/sleep
SORT=/usr/bin/sort
SSH=/usr/bin/ssh
SU=/usr/bin/su
SWAP=/usr/sbin/swap
SYNC=/usr/sbin/sync
TAIL=/usr/bin/tail
TAR=/usr/sbin/tar
TEE=/usr/bin/tee
TOUCH=/usr/bin/touch
TPUT=/usr/bin/tput
TR=/usr/bin/tr
UMOUNT=/usr/sbin/umount
UNAME=/usr/bin/uname
UNSHARE=/usr/bin/unshare
USERADD=/usr/sbin/useradd
WC=/usr/bin/wc

# ********************************************************************
#
#       Configuration Section
#
# ********************************************************************
DEFAULT_USER="root"

# Directory under which all DHCP Client info files are stored. 
# This directory is relative to the $DEFAULT_DHCP_CLIENT_AREA directory
DHCP_CLIENT_DIR=DHCP_CLIENTS

HOST_ARCH=`$UNAME -p`

# Files I will check for to determine if it is a correct Patch 
# distrubtion
UPGRADE_PATCH_REPO="/etc/yum.repos.d/ericUPGRADEPATCH.repo"

# Directory under which all Patch medias are stored. This directory
# is relative to the $PATCH_MEDIA_AREA directory
UPGRADE_PATCH_MEDIA_DIR="UPGRADE_PATCH_MEDIA"

# Gathers time&date
NOW=$($DATE +"%Y-%m-%d-%T")

# Establishes script name used for error mging
SCRIPT_NAME=$(basename $0)

# ********************************************************************
#
#       Functions
#
# ********************************************************************
### Function: abort_script ###
#
#   This will is called if the script is aborted thru an error
#   error signal sent by the kernel such as CTRL-C or if a serious
#   error is encountered during runtime
#
# Arguments:
#       $1 - Error message from part of program (Not always used)
# Return Values:
#       none
abort_script()
{
if [ "$1" ]; then
    _err_msg_=$1
else
    _err_msg_="ERROR: Script aborted...\n"
fi

if [ "${LOGFILE}" ]; then
    $ECHO -e "\n$NOW -- $SCRIPT_NAME \nERROR: Script aborted... $_err_msg_\n" | $TEE -a ${LOGFILE}
else
    $ECHO -e "\n$NOW -- $SCRIPT_NAME \nERROR: $_err_msg_\n"
fi

cd ${SCRIPTHOME}

# Remove the kickstart area if it exists
if [ "${UPGRADE_PATCH_KICK_LOC_AREA}" ]; then
    $RM -rf ${UPGRADE_PATCH_KICK_LOC_AREA}
fi

$RM -rf ${TEM_DIR}
if [ "$2" ]; then
    ${2}
else
    exit 1
fi
}

### Function: add_upgrade_patch_kickstart_area ###
#
# Create a menu, and set up area if required
#
# Arguments:
#   none
# Return Values:
#   none
add_upgrade_patch_kickstart_area()
{
local _upgrade_patch_id_file_ _cnt_ _id_str_ _update_media_info_

# Enable tftp service
#check_tftp_service

# Create /tftpboot sympatchk
#check_tftpboot_link

# Get/Check the location of the Patch image
get_chk_upgrade_patch_image_loc

# Get info about the media
_media_err_=0
_media_label_=`$EGREP "^[[:blank:]]*media_label=" ${UPGRADE_PATCH_MEDIA_ID_FILE} 2>/dev/null | $AWK -F\= '{print $2}'`
if [ ! "${_media_label_}" ]; then
    $ECHO "Failed to read parameter media_label from ${UPGRADE_PATCH_MEDIA_ID_FILE}"
    _media_err_=1
fi

_media_desc_=`$EGREP "^[[:blank:]]*media_desc=" ${UPGRADE_PATCH_MEDIA_ID_FILE} 2>/dev/null | $AWK -F\= '{print $2}'`
if [ ! "${_media_desc_}" ]; then
    $ECHO "Failed to read parameter media_desc from ${UPGRADE_PATCH_MEDIA_ID_FILE}"
    _media_err_=1
fi

_media_prefix_=`$EGREP "^[[:blank:]]*media_prefix=" ${UPGRADE_PATCH_MEDIA_ID_FILE} 2>/dev/null | $AWK -F\= '{print $2}'`
if [ ! "${_media_prefix_}" ]; then
    $ECHO "Failed to read parameter media_prefix from ${UPGRADE_PATCH_MEDIA_ID_FILE}"
    _media_err_=1
fi

_media_num_=`$EGREP "^[[:blank:]]*media_number=" ${UPGRADE_PATCH_MEDIA_ID_FILE} 2>/dev/null | $AWK -F\= '{print $2}'`
if [ ! "${_media_num_}" ]; then
    $ECHO "Failed to read parameter media_number from ${UPGRADE_PATCH_MEDIA_ID_FILE}"
    _media_err_=1
fi

_media_revision_=`$EGREP "^[[:blank:]]*media_rev=" ${UPGRADE_PATCH_MEDIA_ID_FILE} 2>/dev/null | $AWK -F\= '{print $2}'`
if [ ! "${_media_revision_}" ]; then
    $ECHO "Failed to read parameter media_rev from ${UPGRADE_PATCH_MEDIA_ID_FILE}"
    _media_err_=1
fi

_media_arch_=`$EGREP "^[[:blank:]]*media_arch=" ${UPGRADE_PATCH_MEDIA_ID_FILE} 2>/dev/null | $AWK -F\= '{print $2}'`
if [ ! "${_media_arch_}" ]; then
    $ECHO "Failed to read parameter media_arch from ${UPGRADE_PATCH_MEDIA_ID_FILE}"
    _media_err_=1
fi

_media_distro_=`$EGREP "^[[:blank:]]*media_distro=" ${UPGRADE_PATCH_MEDIA_ID_FILE} 2>/dev/null | $AWK -F\= '{print $2}'`
if [ ! "${_media_distro_}" ]; then
    $ECHO "Failed to read parameter media_distro from ${UPGRADE_PATCH_MEDIA_ID_FILE}"
    _media_err_=1
fi

_media_distro_rev_=`$EGREP "^[[:blank:]]*media_distro_rev=" ${UPGRADE_PATCH_MEDIA_ID_FILE} 2>/dev/null | $AWK -F\= '{print $2}'`
if [ ! "${_media_distro_rev_}" ]; then
    $ECHO "Failed to read parameter media_distro_rev from ${UPGRADE_PATCH_MEDIA_ID_FILE}"
    _media_err_=1
fi

_sprint_release_=`$EGREP "^[[:blank:]]*sprint_release=" ${UPGRADE_PATCH_MEDIA_ID_FILE} 2>/dev/null | $AWK -F\= '{print $2}'`
if [ ! "${_sprint_release_}" ]; then
    $ECHO "Failed to read parameter sprint_release from ${UPGRADE_PATCH_MEDIA_ID_FILE}"
    _media_err_=1
fi

_bundle_version_=`$EGREP "^[[:blank:]]*bundle_version=" ${UPGRADE_PATCH_MEDIA_ID_FILE} 2>/dev/null | $AWK -F\= '{print $2}'`
if [ ! "${_bundle_version_}" ]; then
    $ECHO "Failed to read parameter bundle_version from ${UPGRADE_PATCH_MEDIA_ID_FILE}"
    _media_err_=1
fi


# Did I get all parameters
if [ ${_media_err_} -eq 1 ]; then
    _err_msg_=""
    abort_script "$_err_msg_" 
fi

# Do I supported this version of Patch
if [ ! -d ${PARENT_DIR}/patch/${_media_distro_} ]; then
    _err_msg_="Unsupported Patch Distribution....${_media_distro_}"
    abort_script "$_err_msg_" 
else
    UPGRADE_PATCH_DISTRO_DIR=${PARENT_DIR}/patch/${_media_distro_}
fi

# Create a string that can be used for comparing whats already installed
_new_media_version_=${_bundle_version_}
_new_media_version_ide="${_media_prefix_}-${_media_num_}-${_media_revision_}"

# Path to where all PATCH medias are stored
if [ ! -d ${UPGRADE_PATCH_MEDIA_AREA} ]; then
    $MKDIR -p ${UPGRADE_PATCH_MEDIA_AREA}
    if [ $? -ne 0 ]; then
	_err_msg_="Error making Patch media directory\n${UPGRADE_PATCH_MEDIA_AREA}"
	abort_script "$_err_msg_" 
    fi
fi

$RM -f ${TEM_DIR}/existing_media_locations ${TEM_DIR}/existing_media_locations_1

# Get a list of existing Patch areas if any
$LS ${UPGRADE_PATCH_MEDIA_AREA}/*/${UPGRADE_PATCH_MEDIA_INFO_FILE} 2> /dev/null \
    |$EGREP "${UPGRADE_PATCH_MEDIA_AREA}/[1-9][0-9]*" > ${TEM_DIR}/existing_media_locations_1
while read _upgrade_patch_id_file_; do
    if [ -s ${_upgrade_patch_id_file_} ]; then
	$ECHO ${_upgrade_patch_id_file_} >>  ${TEM_DIR}/existing_media_locations
    fi
done <  ${TEM_DIR}/existing_media_locations_1

# Have we got existing areas managed
if [ -s ${TEM_DIR}/existing_media_locations ]; then
    # Build up details of all managed upgrade patch kickstart areas in array
    build_upgrade_patch_media_info_arrays ${TEM_DIR}/existing_media_locations

    # Get number of elements 
    _cnt_=${#UPGRADE_PATCH_KICK_ID_ARRAY[@]}

    # Loop thru and see if this version is already installed. 
    # I will not allow a duplicate. 
    for (( i=1; i<=${_cnt_}; i++ )); do
	if [ "${UPGRADE_PATCH_KICK_ID_ARRAY[${i}]}" == "${_new_media_version_}" ]; then
	    _err_msg_="This media is already installed in\n${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${i}]}"
	    abort_script "$_err_msg_" 
	fi
    done
fi

# Get next location for the Patch Media
cd ${UPGRADE_PATCH_MEDIA_AREA}
_area_list_=`$LS -d * 2>/dev/null| $EGREP "^[1-9][0-9]*$"`
_new_dir_=1
while :; do
    # Are there any existing directories
    if [ "${_area_list_}" ]; then
        # Is the area already in use. If it is then increment counter and loop
	$ECHO ${_area_list_}|$EGREP -w ${_new_dir_}  >> /dev/null 2>&1
	if [ $? -ne 0 ]; then
	    break
	fi
	let _new_dir_=_new_dir_+1
    else
	break
    fi
done
cd ${SCRIPTHOME}

# Store upgrade_patch kickstart area
UPGRADE_PATCH_KICK_LOC_AREA=${UPGRADE_PATCH_MEDIA_AREA}/${_new_dir_}

# Build up the display file
$RM -f ${TEM_DIR}/disp_file.$$
$ECHO -e "\nAdd Upgrade Patches Kickstart Area
==================
Media 		   : ${_media_desc_}
Identity	   : ${_new_media_version_ide}
Location 	   : ${UPGRADE_PATCH_KICK_LOC_AREA}
Arch 		   : ${_media_arch_} 
Revision 	   : ${_media_revision_}
Bundle version     : ${_bundle_version_}
Sprint             : ${_sprint_release_}\n\n
" >> ${TEM_DIR}/disp_file.$$

if [ "$NO_CONFIRM" ]; then
    # Save the details in the logfile
    $CAT $TEM_DIR/disp_file.$$ >> $LOGFILE
    ANS="Yes"
else
    # Get user confirmation if required
    _msg_="\nAre you sure you wish to add the area specified? (Yes|No)"
    user_confirm "${_msg_}"  ${TEM_DIR}/disp_file.$$
fi

if [ "${ANS}" == "Yes" ]; then

    $ECHO -e "\n$NOW -- $SCRIPT_NAME \nCreating upgrade patch kickstart directory ${UPGRADE_PATCH_KICK_LOC_AREA}" | $TEE -a $LOGFILE
    $ECHO "Please wait..."

    # Copy the Media
    $MKDIR -p ${UPGRADE_PATCH_KICK_LOC_AREA}
    cd ${PATCH_PATH}
    $FIND . -depth -print |$CPIO -pdmu ${UPGRADE_PATCH_KICK_LOC_AREA} >> /dev/null 2>/dev/null
    if [ $? -ne 0 ]; then 
	_err_msg_="Could not copy files from ${PATCH_PATH} \nto ${UPGRADE_PATCH_KICK_LOC_AREA}"
	abort_script "$_err_msg_"
    fi

    $CAT ${UPGRADE_PATCH_MEDIA_ID_FILE}|$EGREP -v "(media_location=\/|media_add_date=[0-9])"   \
            > ${TEM_DIR}/media_info_file
    if [ $? -ne 0 ]; then
	_err_msg_="Could not add main details to temporary patch area ini file"
	abort_script "$_err_msg_"
    fi

    # Store Media Location
    $ECHO "media_location=${UPGRADE_PATCH_KICK_LOC_AREA}"|$SED -e 's/\/[\/]*/\//g' -e 's/[\/]*$//g' >> ${TEM_DIR}/media_info_file
    if [ $? -ne 0 ]; then
	_err_msg_="Could not add location details to temporary Patch area  file"
	abort_script "$_err_msg_"
    fi

    # Store the media creation time
    _add_time_=`$DATE '+%Y-%b-%d_%H.%M.%S'`
    $ECHO "media_add_date=${_add_time_}" >> ${TEM_DIR}/media_info_file
    if [ $? -ne 0 ]; then
	_err_msg_="Could not add time creation details to temporary Patch area  file"
	abort_script "$_err_msg_"
    fi

    # Copy the media info to the ${UPGRADE_PATCH_MEDIA_INFO_FILE}
    $CP ${TEM_DIR}/media_info_file ${UPGRADE_PATCH_KICK_LOC_AREA}/${UPGRADE_PATCH_MEDIA_INFO_FILE}
    if [ $? -ne 0 ]; then
        _err_msg_="Could not add media info details to\n ${UPGRADE_PATCH_MEDIA_ID_FILE}"
        abort_script "$_err_msg_"
    fi
    $ECHO "Done."	
fi
}

### Function: check_upgrade_patch_path ###
#
# Determine absolute path to software
# changed for new type of media
#
# Arguments:
#   none
# Return Values:
#   none
check_upgrade_patch_path()
{
local _upgrade_patch_path_ _current_release_
_upgrade_patch_path_=$1
_l_valid_=true
_current_rhelpackage_dir_=${_upgrade_patch_path_}/RHEL/RHEL[0-9]*/packages
   if [ -s ${_upgrade_patch_path_} ]; then
	if [ -d ${_current_rhelpackage_dir_} ]; then
		_current_release_=${_upgrade_patch_path_}/RHEL/RHEL[0-9]*
		if [ "${_current_release_}" ]; then
			export MY_RHEL_VERSION=$(basename ${_current_release_} | cut -d- -f2)
		fi
	else
		_l_valid_=false
	fi
   else
	[[ ! -s ${_upgrade_patch_path_}/.upgrade_patch_boot_media ]] && { 
		_l_valid_=false 
	}
   fi
	
	[[ ${_l_valid_} == "false" ]] && {	
	$ECHO -e "\n$NOW -- $SCRIPT_NAME \nPath to Patch Software is invalid." | $TEE -a ${LOGFILE}
        return 1
	}

return 0

}

### Function: check_params ###
#
# Check the Input Parameters.
#
# Arguments:
#       none
# Return Values:
#       none
check_params()
{
if [ ! "${ACTION}" ]; then
    usage_msg
    exit 1
fi

case "${ACTION}" in
    add)    :		
       ;;
    list)   :
       ;;
    remove) :
       ;;
    *) 	    usage_msg
	    exit 1
       ;;
esac

if [ "${ACTION}" == "add" ]; then
    if [ "${PATH_TO_UPGRADE_PATCH}" ]; then
	# Check that a full pathname was specified
	check_full_pathname ${PATH_TO_UPGRADE_PATCH}
	if [ $? -ne 0 ]; then
	    _err_msg_="${PATH_TO_UPGRADE_PATCH} is not a full pathname."
	    abort_script "$_err_msg_"
	fi
    fi

    # Check that a full pathname was specified for release directory
    check_full_pathname ${UPGRADE_PATCH_RELEASE_DIR}
    if [ $? -ne 0 ]; then
	_err_msg_="${UPGRADE_PATCH_RELEASE_DIR} is not a full pathname."
	abort_script "$_err_msg_"
    fi

	if [  "${OUT_DIR}" ]; then
	    usage_msg
	    exit 1
	fi
fi

# Check if on root filesystem
cd /
_root_dev_=`$DF -lk .|$TAIL -1|$AWK '{print $1}'`
cd ${UPGRADE_PATCH_MEDIA_AREA}
_upgrade_patch_kick_dev_=`$DF -lk .|$TAIL -1|$AWK '{print $1}'`

if [ "${_root_dev_}" == "${_upgrade_patch_kick_dev_}" ]; then
    _err_msg_="Upgrade Patch Kickstart directory not allowed to be on root filesystem"
    abort_script "$_err_msg_"
fi

cd ${SCRIPTHOME}
}


### Function: chk_create_logfile ###
#
# Check/Create Logfile
#
# Arguments:
#   none
# Return Values:
#   none
chk_create_logfile()
{
$MKDIR -p `$DIRNAME ${LOGFILE}`
if [ $? -ne 0 ]; then
    _err_msg_="Could not create directory `$DIRNAME ${LOGFILE}`"
    abort_script "$_err_msg_"
fi

if [ -d ${LOGFILE} ]; then
    _err_msg_="${LOGFILE} is a directory"
    abort_script "$_err_msg_"
fi

$TOUCH -a ${LOGFILE}
if [ $? -ne 0 ]; then
    _err_msg_="Could not write to file ${LOGFILE}"
    abort_script "$_err_msg_"
fi
}

### Function: extract_pxepatch0 ###
#
# Extract the pxepatch.0 file from the red hat media
#
# Arguments:
#   none
# Return Values:
#   none

extract_pxepatch0()
{


local _upgrade_patch_path_=$1
#local _pxe_destination_=${UPGRADE_PATCH_LOC_AREA}/pxepatch
local _currentdir_="`pwd`"
#local _tempdir_=/tmp/pxe$$
#local _pxepatch0_

$MKDIR -p ${_tempdir_}

if [[ ! "$PATH" =~ "/usr/local/bin" ]]
   then
   PATH="$PATH:/usr/local/bin"
   export PATH
fi


RPM2CPIO=${PARENT_DIR}/bin/rpm2cpio_new

#SYSPATCH_FILE="`$FIND ${_upgrade_patch_path_} -print | $GREP syspatch- | $HEAD -1`"

#if [ ! -s ${SYSPATCH_FILE} ]; then
#   _err_msg_="The file ${SYSPATCH_FILE} does not exist on media"
#   abort_script "$_err_msg_"
#fi


#_pxepatch0_="`$RPM2CPIO ${SYSPATCH_FILE} | cpio -it | $EGREP  "\/pxepatch.0"`" >> ${TEM_DIR}/rpm2cpio.log 2>&1
#if [ $? -ne 0 ]; then
#   _err_msg_="Could not locate pxepatch.0"
#   abort_script "$_err_msg_"
#fi
#
#cd ${_tempdir_}
#$RPM2CPIO $SYSPATCH_FILE | cpio -idv ${_pxepatch0_} >> ${TEM_DIR}/rpm2cpio.log 2>&1
#if [ $? -ne 0 ]; then
#   _err_msg_="Could not extract pxepatch.0"
#   abort_script "$_err_msg_"
#fi

#$CP ${_pxepatch0_} ${_pxe_destination_}
#if [ $? -ne 0 ]; then
#   _err_msg_="Could not copy pxepatch.0 to ${_pxe_destination_}"
#   abort_script "$_err_msg_"
#fi

cd ${_currentdir_}


if [ ${_tempdir_} ]; then
$RM -r ${_tempdir_}
fi

return 0
}


### Function: get_absolute_path ###
#
# Determine absolute path to software
#
# Arguments:
#   none
# Return Values:
#   none
get_absolute_path()
{
_dir_=`$DIRNAME $0`
SCRIPTHOME=`cd $_dir_ 2>/dev/null && pwd || $ECHO $_dir_`
PARENT_DIR=`$DIRNAME ${SCRIPTHOME}`
}

### Function: get_chk_upgrade_patch_image_loc ###
#
# Get/Check the location of the Patch image
#
# Arguments:
#   none
# Return Values:
#   none
get_chk_upgrade_patch_image_loc()
{
# Was I give the path to the patch 
if [ "${PATH_TO_UPGRADE_PATCH}" ]; then
    # Check for validity of Patch path
    check_upgrade_patch_path ${PATH_TO_UPGRADE_PATCH}
    if [ $? -ne 0 ]; then
	_err_msg_="Invalid Patch Distribution under path\n${PATH_TO_UPGRADE_PATCH}"
	abort_script "$_err_msg_"
    fi
    PATCH_PATH=${PATH_TO_UPGRADE_PATCH}
else
    #$CLEAR 
    $PRINTF "\033c"
    while :; do
	$ECHO -e "\nEnter full path to the location of the Upgrade Patch SW"
	read _ans_
	
	if [ ! ${_ans_} ]; then
	    continue
	else
	    # Check that a full pathname was specified
	    check_full_pathname ${_ans_}
	    if [ $? -ne 0 ]; then
		$ECHO "${_ans_} is not a full pathname."
		continue
	    fi	    

            # Check for validity of Patch path
	    check_upgrade_patch_path ${_ans_}
	    if [ $? -eq 0 ]; then
		PATCH_PATH=${_ans_}
		break
	    else
		$ECHO -e "Invalid Patch Distribution under path\n${_ans_}\n\n"
		continue
	    fi
	fi
    done
fi

if [ -s ${UPGRADE_PATCH_PATH}/${UPGRADE_PATCH_MEDIA_INFO_FILE} ]; then
    export UPGRADE_PATCH_MEDIA_ID_FILE=${UPGRADE_PATCH_PATH}/${UPGRADE_PATCH_MEDIA_INFO_FILE}
else
    if [ -s ${UPGRADE_PATCH_IDENTITY_DIR}/${MY_UPGRADE_PATCH_VERSION} ]; then
        export UPGRADE_PATCH_MEDIA_ID_FILE=${UPGRADE_PATCH_IDENTITY_DIR}/${MY_RHEL_VERSION}
    else
        _err_msg_="Could not find media identity file\n${UPGRADE_PATCH_MEDIA_ID_FILE}"
    	abort_script "$_err_msg_"
    fi
fi

}

### Function: list_upgrade_patch_kickstart_area ###
#
# List current kickstart areas
#
# Arguments:
#   none
# Return Values:
#   none
list_upgrade_patch_kickstart_area()
{
local _cnt_
$PRINTF "\033c"
#$CLEAR
# Get a list of existing Patch areas if any
$RM -f ${TEM_DIR}/existing_media_locations ${TEM_DIR}/existing_media_locations_1
$LS ${UPGRADE_PATCH_MEDIA_AREA}/*/${UPGRADE_PATCH_MEDIA_INFO_FILE} 2> /dev/null \
    |$EGREP "${UPGRADE_PATCH_MEDIA_AREA}/[1-9][0-9]*" > ${TEM_DIR}/existing_media_locations_1
while read _upgrade_patch_id_file_; do
    if [ -s ${_upgrade_patch_id_file_} ]; then
	$ECHO ${_upgrade_patch_id_file_} >>  ${TEM_DIR}/existing_media_locations
    fi
done <  ${TEM_DIR}/existing_media_locations_1

# Have we got existing areas managed
if [ ! -s ${TEM_DIR}/existing_media_locations ]; then
    $ECHO -e "\nNo upgrade patch kickstart areas created\n"
    return 0
fi

# Build up details of all managed kickstart areas in array
build_upgrade_patch_media_info_arrays ${TEM_DIR}/existing_media_locations

# Get number of elements 
_cnt_=${#UPGRADE_PATCH_KICK_ID_ARRAY[@]}

if [ "${FORMATTED_OUTPUT}" ]; then
    for (( i=1; i<=${_cnt_}; i++ )); do
	$ECHO "patch@${UPGRADE_PATCH_KICK_ID_ARRAY[${i}]}@${UPGRADE_PATCH_KICK_ARCH_ARRAY[${i}]}@${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${i}]}" 
    done
    return 0
fi

if [ "${USER_UPGRADE_PATCH_KICK_AREA}" ]; then
    _found_=0
    # Loop thru and see if this version is already installed. 
    for (( i=1; i<=${_cnt_}; i++ )); do
	if [ "${UPGRADE_PATCH_KICK_ID_ARRAY_1[${i}]}" == "${USER_UPGRADE_PATCH_KICK_AREA}" ]; then
	    _found_=1
	    break
	fi
    done

    if [ ${_found_} -ne 1 ]; then
	$ECHO "Install patch Kickstart area ${USER_UPGRADE_PATCH_KICK_AREA} not found"
	return 0
    fi

    printf "%-15s%s\n"   "Description : "    "${UPGRADE_PATCH_KICK_DESC_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
    printf "%-15s%s\n"   "Identity : "      "${UPGRADE_PATCH_KICK_ID_ARRAY_1[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
    printf "%-15s%s\n"   "Path : "          "${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
    printf "%-15s%s\n"   "Architecture : "   "${UPGRADE_PATCH_KICK_ARCH_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
    printf "%-15s%s\n" "Date Added : "  "  ${UPGRADE_PATCH_KICK_DATE_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$         printf "%-15s%s\n" "Sprint Release : "  "  ${UPGRADE_PATCH_SPRINT_RELEASE_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
    printf "%-15s%s\n\n" "Bundle version : "  "  ${UPGRADE_PATCH_KICK_ID_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
else
    for (( i=1; i<=${_cnt_}; i++ )); do
	printf "%-8s%-15s%s\n" "[${i}]" "Description    : " "${UPGRADE_PATCH_KICK_DESC_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n" ""       "Identity       : " "${UPGRADE_PATCH_KICK_ID_ARRAY_1[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n" ""       "Path           : " "${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n" ""       "Architecture   : " "${UPGRADE_PATCH_KICK_ARCH_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n" ""       "Date Added     : " "${UPGRADE_PATCH_KICK_DATE_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n" ""       "Sprint Release : "  "${UPGRADE_PATCH_SPRINT_RELEASE_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n\n" ""     "Bundle version : "  "${UPGRADE_PATCH_KICK_ID_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
    done
fi
$MORE -d ${TEM_DIR}/upgrade_patch_kick_menu.$$

# Do I need to hold the Display for User
if [ "${HOLD_LISTING}" ]; then
    $ECHO -e "\nPress any key to return to menu"
    read _any_
fi
}

### Function: remove_upgrade_patch_kickstart_area ###
#
# Remove a kickstart area
#
# Arguments:
#   none
# Return Values:
#   none
remove_upgrade_patch_kickstart_area()
{
local _cnt_ _client_cnt_

$PRINTF "\033c"
# Get a list of existing Patch areas if any
$RM -f ${TEM_DIR}/existing_media_locations ${TEM_DIR}/existing_media_locations_1
$LS ${UPGRADE_PATCH_MEDIA_AREA}/*/${UPGRADE_PATCH_MEDIA_INFO_FILE} 2> /dev/null \
    |$EGREP "${UPGRADE_PATCH_MEDIA_AREA}/[1-9][0-9]*" > ${TEM_DIR}/existing_media_locations_1
while read _upgrade_patch_id_file_; do
    if [ -s ${_upgrade_patch_id_file_} ]; then
	$ECHO ${_upgrade_patch_id_file_} >>  ${TEM_DIR}/existing_media_locations
    fi
done <  ${TEM_DIR}/existing_media_locations_1

# Have we got existing areas managed
if [ ! -s ${TEM_DIR}/existing_media_locations ]; then
    $ECHO -e "\nNo upgrade patch kickstart areas created\n"
    return 0
fi

# Build up details of all managed kickstart areas in array
build_upgrade_patch_media_info_arrays ${TEM_DIR}/existing_media_locations

# Get number of elements 
_kick_cnt_=${#UPGRADE_PATCH_KICK_ID_ARRAY[@]}

# Get a list of existing Client Info file(s) if any
$RM -f ${TEM_DIR}/existing_dhcp_clients ${TEM_DIR}/existing_dhcp_clients_1
$LS ${DHCP_CLIENT_AREA}/* 2> /dev/null > ${TEM_DIR}/existing_dhcp_clients_1
while read _dhcp_client_info_file_; do
    if [ -s ${_dhcp_client_info_file_} ]; then
	$ECHO ${_dhcp_client_info_file_} >> ${TEM_DIR}/existing_dhcp_clients
    fi
done < ${TEM_DIR}/existing_dhcp_clients_1

# Have we got existing Client Info file(s)
if [ -s ${TEM_DIR}/existing_dhcp_clients ]; then
    # Build up details of all dhcp clients in array
    build_patch_client_info_arrays ${TEM_DIR}/existing_dhcp_clients

    # Get number of elements 
    _client_cnt_=${#CLIENT_HOSTNAME_ARRAY[@]}
else
    _client_cnt_=0
fi

if [ "${USER_UPGRADE_PATCH_KICK_AREA}" ]; then
    _found_=0
    # Loop thru and see if this version is already installed. 
    for (( i=1; i<=${_kick_cnt_}; i++ )); do
	if [ "${UPGRADE_PATCH_KICK_ID_ARRAY_1[${i}]}" == "${USER_UPGRADE_PATCH_KICK_AREA}" ]; then
	    _found_=1
	    break
	fi
    done

    if [ ${_found_} -ne 1 ]; then
	$ECHO "Kickstart area ${USER_UPGRADE_PATCH_KICK_AREA} not found"
	return 0
    fi

    # Store the choice
    _opt_=${i}

    $RM -f ${TEM_DIR}/upgrade_patch_kick_area_clients ${TEM_DIR}/user_msg
    for (( i=1; i<=${_client_cnt_}; i++ )); do
	if [ "${CLIENT_UPGRADE_PATCH_KICK_ID_ARRAY[${i}]}" == "${USER_UPGRADE_PATCH_KICK_AREA}" ]; then
	    $ECHO "${CLIENT_HOSTNAME_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_area_clients 
	    break
	fi
    done

    if [ -f ${TEM_DIR}/upgrade_patch_kick_area_clients ]; then
	$PRINTF "\033c"
	$ECHO -e "\nKickstart areas still in use by the following kickstart clients" >> ${TEM_DIR}/user_msg
	$CAT  ${TEM_DIR}/upgrade_patch_kick_area_clients>> ${TEM_DIR}/user_msg
	$MORE -d ${TEM_DIR}/user_msg
	return 0
    fi
else
    for (( i=1; i<=${_kick_cnt_}; i++ )); do
	printf "%-8s%-15s%s\n" "[${i}]" "Description : " "${UPGRADE_PATCH_KICK_DESC_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n" "" "Identity : " "${UPGRADE_PATCH_KICK_ID_ARRAY_1[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n" "" "Path : " "${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n" "" "Architecture : " "${UPGRADE_PATCH_KICK_ARCH_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n" "" "Date Added : " "${UPGRADE_PATCH_KICK_DATE_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
	printf "%-8s%-15s%s\n" "" "Sprint Release : " "${UPGRADE_PATCH_SPRINT_RELEASE_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
    printf "%-8s%-15s%s\n\n" "" "Bundle version : " "${UPGRADE_PATCH_KICK_ID_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$
    done
    $ECHO "Select number of the area you wish to remove or (q) to quit" >> ${TEM_DIR}/upgrade_patch_kick_menu.$$

    # Display the menu and get user choice
    while :; do
	$PRINTF "\033c"
	$MORE -d ${TEM_DIR}/upgrade_patch_kick_menu.$$
	read _opt_
	
	if [ ! ${_opt_} ]; then
	    continue
	fi
	
	if [ "${_opt_}" == "q" ]; then
	    return 0
	fi

	$ECHO ${_opt_} | $EGREP '[^0-9]' >> /dev/null 2>&1
	if [ $? -eq 0 ]; then
	    continue
	fi
	if [ ${_opt_} -lt 1 -o ${_opt_} -gt ${_kick_cnt_} ]; then
	    continue
	fi

	$RM -f ${TEM_DIR}/upgrade_patch_kick_area_clients ${TEM_DIR}/user_msg
	for (( i=1; i<=${_client_cnt_}; i++ )); do
	    if [ "${CLIENT_UPGRADE_PATCH_KICK_ID_ARRAY[${i}]}" == "${UPGRADE_PATCH_KICK_ID_ARRAY[${_opt_}]}" ]; then
		$ECHO "${CLIENT_HOSTNAME_ARRAY[${i}]}" >> ${TEM_DIR}/upgrade_patch_kick_area_clients 
		# break
	    fi
	done

	if [ -f ${TEM_DIR}/upgrade_patch_kick_area_clients ]; then
	    $PRINTF "\033c"
	    $ECHO -e "\nKickstart areas still in use by the following upgrade patches kickstart clients" >> ${TEM_DIR}/user_msg
	    $CAT  ${TEM_DIR}/upgrade_patch_kick_area_clients >> ${TEM_DIR}/user_msg
	    $ECHO "Press any key to continue" >> ${TEM_DIR}/user_msg
	    $MORE -d  ${TEM_DIR}/user_msg
	    read _any_
	    continue	
	fi
	break
    done
fi

# Create a user confirmation display file
printf "%-15s%s\n"   "Description : " "${UPGRADE_PATCH_KICK_DESC_ARRAY[${_opt_}]}" >> ${TEM_DIR}/disp_file.$$
printf "%-15s%s\n"   "Identity : "    "${UPGRADE_PATCH_KICK_ID_ARRAY_1[${_opt_}]}" >> ${TEM_DIR}/disp_file.$$
printf "%-15s%s\n"   "Path : "        "${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${_opt_}]}" >> ${TEM_DIR}/disp_file.$$
printf "%-15s%s\n"   "Architecture : "  "${UPGRADE_PATCH_KICK_ARCH_ARRAY[${_opt_}]}" >> ${TEM_DIR}/disp_file.$$
printf "%-15s%s\n" "Date Added : "  "${UPGRADE_PATCH_KICK_DATE_ARRAY[${_opt_}]}" >> ${TEM_DIR}/disp_file.$$
printf "%-15s%s\n"   "Sprint Release : "  "${UPGRADE_PATCH_SPRINT_RELEASE_ARRAY[${_opt_}]}" >> ${TEM_DIR}/disp_file.$$
printf "%-15s%s\n\n" "Bundle version : "  "${UPGRADE_PATCH_KICK_ID_ARRAY[${_opt_}]}" >> ${TEM_DIR}/disp_file.$$

if [ "$NO_CONFIRM" ]; then
    # Save the details in the logfile
    $CAT ${TEM_DIR}/disp_file.$$ >> $LOGFILE
    ANS="Yes"
else
    _msg_="\nAre you sure you wish to remove the selected upgrade patches kickstart area? (Yes|No)"
    user_confirm "${_msg_}"  ${TEM_DIR}/disp_file.$$
fi

# Are we removing?
if [ "${ANS}" == "Yes" ]; then
    _dfstab_=/etc/exports
    _fstab_=/etc/fstab

    # Unshare the filesystem if shared out explicitly. 
    $UNSHARE ${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${_opt_}]} >> /dev/null 2>&1

    # Remove from the fstab if present
    $CAT ${_fstab_} | $EGREP -v "^[[:blank:]]*${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${_opt_}]}/boot" > ${TEM_DIR}/fstab.$$

    # Do I need to update the fstab file
    $CMP -s ${_fstab_} ${TEM_DIR}/fstab.$$
    if [ $? -ne 0 ]; then
        $CAT ${_fstab_} | $EGREP "^[[:blank:]]*${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${_opt_}]}/boot" \
	    | $AWK '{print $1,$3}' > ${TEM_DIR}/umount_list.$$

	while read _fs_ _mnt_dir_; do
	    $ECHO -e "\n$NOW -- $SCRIPT_NAME \nUnmounting ${_fs_}"|$TEE -a $LOGFILE
	    $UMOUNT ${_fs_} >> /dev/null 2>&1
	    
	    $RMDIR ${_mnt_dir_} >> /dev/null 2>&1
	    if [ $? -eq 0 ]; then
		$ECHO -e "\n$NOW -- $SCRIPT_NAME \nRemoved directory ${_mnt_dir_}"|$TEE -a $LOGFILE
	    fi			    
	done < ${TEM_DIR}/umount_list.$$

	$ECHO -e "\n$NOW -- $SCRIPT_NAME \nRemoving ${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${_opt_}]}/boot\nfrom ${_fstab_}"|$TEE -a $LOGFILE
	$CP ${TEM_DIR}/fstab.$$ ${_fstab_}  >> /dev/null 2>&1
    fi    

    # Remove from the dfstab if present
    $CAT ${_fstab_} | $EGREP -v "[[:blank:]]*${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${_opt_}]}[[:blank:]]*$" > ${TEM_DIR}/fstab.$$

    # Do I need to update the dfstab file
    $CMP -s ${_dfstab_} ${TEM_DIR}/dfstab.$$
    if [ $? -ne 0 ]; then
	$ECHO -e "\n$NOW -- $SCRIPT_NAME \nRemoving ${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${_opt_}]}\nfrom ${_dfstab_}"|$TEE -a $LOGFILE
	$CP ${TEM_DIR}/dfstab.$$ ${_dfstab_}  >> /dev/null 2>&1
    fi
	
	#remove ENM_initrd if no patchks point to it
	_l_enm_intrd_=ENM_initrd.img
	_l_rhel_minor_ver_=$(echo ${KICK_DESC_ARRAY[${_opt_}]}|$AWK ' { print $4 } ')
	if [ -f /tftpboot/RHEL_${_l_rhel_minor_ver_}/${_l_enm_intrd_} ]; then
	_l_list_patchks_=$(find /tftpboot/RHEL_${_l_rhel_minor_ver_} -type l -exec ls -l {} \; -print | grep ${_l_enm_intrd_})
	if [ -n "${_l_list_patchks_}" ]; then
		$ECHO -e "\n$NOW -- CAN'T REMOVE ${_l_enm_intrd_}"
	else
		echo "\n$NOW -- WILL REMOVE ${_l_enm_intrd_}"
		$RM -f /tftpboot/RHEL_${_l_rhel_minor_ver_}/${_l_enm_intrd_}
		if [ $? -ne 0 ]; then
        	_err_msg_="Failed to remove ${_l_enm_intrd_}"
		abort_script "$_err_msg_"
		fi
	fi
	fi

    $ECHO -e "\n$NOW -- $SCRIPT_NAME \nRemoving kickstart directory ${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${_opt_}]}" | $TEE -a $LOGFILE
    $ECHO "Please wait..."
    $RM -rf ${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${_opt_}]}
    if [ $? -ne 0 ]; then
	_err_msg_="Failed to remove ${UPGRADE_PATCH_KICK_LOCATION_ARRAY[${_opt_}]}"
	abort_script "$_err_msg_"
    fi
fi
}

### Function: setup_env ###
#
# Set up environment variables for script.
#
# Arguments:
#   none
# Return Values:
#   none
setup_env()
{
# Set Remote handled FLAG. Basically determines if we are running
# remote ERICkick directories. Needed for internal testing where we
# are trying to avoid the need for multiple MWS. Not required in
# customer world
_rmt_chk_=`$CAT ${UPGRADE_PATCH_CONFIG}|$EGREP "^[[:blank:]]*DEFAULT_INSTALLATION_TYPE=" \
	| $AWK -F\= '{print $2}'`

if [ "${_rmt_chk_}" ]; then
    if [ "${_rmt_chk_}" == "remote" ]; then
	REMOTE_ERICKICK=Yes
    fi
fi

# Set the default kickstart location if not specified & Strip of any extra '/'
UPGRADE_PATCH_MEDIA_AREA=`$CAT ${UPGRADE_PATCH_CONFIG}|$EGREP "^[[:blank:]]*DEFAULT_UPGRADE_PATCH_MEDIA_AREA=" \
	| $AWK -F\= '{print $2}'|$SED -e 's/\/[\/]*/\//g' -e 's/[\/]*$//g'`
if [ ! "${UPGRADE_PATCH_MEDIA_AREA}" ]; then
    _err_msg_="Failed to read parameter DEFAULT_UPGRADE_PATCH_MEDIA_AREA from \n${UPGRADE_PATCH_CONFIG}"
    abort_script "$_err_msg_"
fi

# Parameter to indicate the media identity file of 
# the Patch media
UPGRADE_PATCH_MEDIA_INFO_FILE=`$CAT ${UPGRADE_PATCH_CONFIG}|$EGREP "^[[:blank:]]*UPGRADE_PATCH_MEDIA_INFO_FILE=" \
	| $AWK -F\= '{print $2}'`
if [ ! "${UPGRADE_PATCH_MEDIA_INFO_FILE}" ]; then
    _err_msg_="Failed to read parameter UPGRADE_PATCH_PATCH_MEDIA_INFO_FILE from ${UPGRADE_PATCH_CONFIG}"
    abort_script "$_err_msg_"
fi

# Make sure it is a full pathname
check_full_pathname ${UPGRADE_PATCH_MEDIA_AREA}
if [ $? -ne 0 ]; then
    _err_msg_="Main Patch Media area ${UPGRADE_PATCH_MEDIA_AREA} is not a full pathname."
    abort_script "$_err_msg_"
fi

if [ "${REL_DIR}" ]; then
    UPGRADE_PATCH_RELEASE_DIR="${REL_DIR}"
else
    UPGRADE_PATCH_RELEASE_DIR="${PARENT_DIR}/release"
fi

# Make the directory if required
UPGRADE_PATCH_MEDIA_AREA=${UPGRADE_PATCH_MEDIA_AREA}/${UPGRADE_PATCH_MEDIA_DIR}
if [ ! -d ${UPGRADE_PATCH_MEDIA_AREA} ]; then
    $MKDIR -p ${UPGRADE_PATCH_MEDIA_AREA}
    if [ $? -ne 0 ]; then
	_err_msg_="Could not create kickstart SW directory ${UPGRADE_PATCH_MEDIA_AREA}"
	abort_script "$_err_msg_"
    fi
fi

# Set the default DHCP Client info file area
DEFAULT_DHCP_CLIENT_AREA=`$CAT ${UPGRADE_PATCH_CONFIG}|$EGREP "^[[:blank:]]*DEFAULT_DHCP_CLIENT_AREA=" \
	| $AWK -F\= '{print $2}'`
if [ ! "${DEFAULT_DHCP_CLIENT_AREA}" ]; then
    _err_msg_="Failed to read parameter DEFAULT_DHCP_CLIENT_AREA from \n${UPGRADE_PATCH_CONFIG}"
    abort_script "$_err_msg_"
fi
DHCP_CLIENT_AREA="${DEFAULT_DHCP_CLIENT_AREA}/${DHCP_CLIENT_DIR}"

export UPGRADE_PATCH_IDENTITY_DIR=${UPGRADE_PATCH_RELEASE_DIR}/${HOST_ARCH}/upgrade_patch_media_identity/${VENDOR}
if [ ! -d $UPGRADE_PATCH_IDENTITY_DIR ] ; then
	_err_msg_="Can't find release information from $UPGRADE_PATCH_IDENTITY_DIR"
	abort_script "$_err_msg_"
fi

}

### Function: user_confirm ###
#
# Confirm details
#
# Arguments:
#   none
# Return Values:
#   none
user_confirm()
{
if [ "$NO_CONFIRM" ]; then
    ANS="Yes"
    return
fi

local _msg_=$1
local _file_=$2

while :; do
    $PRINTF "\033c"
    if [ -f "$2" ]; then
	$CAT $2
    fi
    $ECHO -e "\n${_msg_}"
    read _ans_
    
    if [ ! "${_ans_}" ]; then
	continue
    fi
    
    if [ "${_ans_}" == "Yes" -o "${_ans_}" == "No" ]; then
	ANS="${_ans_}"
	break
    fi	
done
}

### Function: usage_msg ###
#
#  Usage message
#
# Arguments:
#   none
# Return Values:
#   none
usage_msg() 
{
$CLEAR
# Loop until we get a unique file name 
_tmp_file_=/tmp/manage_upg_patch_kickstart_usage.$$.$$
while :; do
    if [ ! -f ${_tmp_file_} ]; then
	break
    fi
    _tmp_file_=${_tmp_file_}.$$
done

$ECHO "
Usage: `$BASENAME $0` -a { add | list | remove } 
              [ -k <upgrade_patch_kickstart_identity> ] 
              [ -l <path_to_logfile> ]
	      [ -p <path_to_patch> ] [ -N ]

options:

-a  : Parameter containing action to be performed
          add : Add a new upgrade patch kickstart location
         list : List current upgrade patch kickstart locations
       remove : Remove a current upgrade patch kickstart area

-l  : Optional parameter specifying the full path to logfile. If not 
      specified, a logfile will be created in ${PARENT_DIR}/log
      

In the case of kickstart addition, the following paramters are valid.
=====================================================================
-N  : Optional parameter specifying whether the script will prompt 
      for user confirmation or not. 

-p  : Optional parameter specifying the full path to where the
      Patch image is located.If not specified, then a user will 
      be prompted for location interactively.


In the case of kickstart listing, the following paramters are valid.
====================================================================

-k  : Optional parameter specifying identity of the kickstart area
      that is to be listed. E.g.19089-LZY2144638-H
      

In the case of kickstart removal, the following paramters are valid.
====================================================================

-k  : Optional parameter specifying identity of the kickstart area
      that is to be removed. E.g.19089-LZY2144638-H
      
-N  : Optional parameter specifying whether the script will prompt 
      for user confirmation or not. 
      
" > ${_tmp_file_}
$MORE -d  ${_tmp_file_}
$RM -f ${_tmp_file_}
}

# ********************************************************************
#
#   Main body of program
#
# ********************************************************************
#
RUN_TIME=`$DATE '+%Y-%b-%d_%H.%M.%S'`

# Determine absolute path to software
get_absolute_path

# Check for the common functions
_common_funcs_lib_="${PARENT_DIR}/lib/common_ericks_functions.lib"
if [ ! -s ${_common_funcs_lib_} ]; then
    _err_msg_="${_common_funcs_lib_} not found or is empty"
    abort_script "$_err_msg_"
fi

# Source the common functions
. ${_common_funcs_lib_}
if [ $? -ne 0 ]; then
    _err_msg_="Error sourcing the common functions library\n${_common_funcs_lib_}"
    abort_script "$_err_msg_"
fi

# Check the id of the user
check_id ${DEFAULT_USER}
if [ $? -ne 0 ]; then
    _err_msg_="You must be ${DEFAULT_USER} to execute this script."
    abort_script "$_err_msg_"
fi

while getopts ":a:FHk:l:Np:v:" arg; do
    case $arg in
	a) ACTION="$OPTARG"
	    ;;
	F) FORMATTED_OUTPUT="YES"
	    ;;
	H) HOLD_LISTING="YES"
	    ;;
	k) USER_UPGRADE_PATCH_KICK_AREA="$OPTARG"
	    ;;
	l) LOGFILE="$OPTARG"
	    ;;
	N) NO_CONFIRM="YES"
	    ;;
	p) PATH_TO_UPGRADE_PATCH="$OPTARG"
	    ;;
	v) VENDOR="$OPTARG"
	    ;;
	\?) usage_msg
	    exit 1
	;;
    esac
done
shift `expr $OPTIND - 1`

# Check for the ERICkick config file
UPGRADE_PATCH_CONFIG_TEMPLATE="${PARENT_DIR}/template/upgrade_patchks_config_template"
UPGRADE_PATCH_CONFIG="${PARENT_DIR}/etc/upgrade_patchks_config"
if [ ! -s ${UPGRADE_PATCH_CONFIG} ]; then
    if [ ! -s ${UPGRADE_PATCH_CONFIG_TEMPLATE} ]; then
	_err_msg_="${UPGRADE_PATCH_CONFIG_TEMPLATE} not found or is empty"
	abort_script "$_err_msg_"
    else
	$CP ${UPGRADE_PATCH_CONFIG_TEMPLATE} ${UPGRADE_PATCH_CONFIG}
    fi
fi

PORT_PING=${PARENT_DIR}/lib/port_ping.pl
if [ ! -x ${PORT_PING} ]; then
    _err_msg_="${PORT_PING} not found or not executable"
    abort_script "$_err_msg_"    
fi

#assume default vendor 
[[ ! "${VENDOR}" ]] &&  VENDOR="REDHAT"


# Set up environment variables for script.
setup_env

trap "abort_script" 1 2 3 14 15
# Loop until we get a unique directory name 
TEM_DIR=/tmp/manage_upgrade_patch_kickstart.$$.$$
while :; do
    $LS ${TEM_DIR} >> /dev/null 2>&1
    if [ $? -ne 0 ]; then
	break
    fi
    TEM_DIR=${TEM_DIR}.$$
done
$MKDIR -p ${TEM_DIR}
if [ $? -ne 0 ]; then
    _err_msg_="Could not create directory ${TEM_DIR}"
    abort_script "$_err_msg_"
fi

# Log file
if [ ! "${LOGFILE}" ]; then
    LOGFILE="${PARENT_DIR}/log/manage_upgrade_patch_kickstart.log"
fi	

# Check/Create Logfile
chk_create_logfile

# Check the input parameters
check_params

# Perform Required Action
case ${ACTION} in
    add)          add_upgrade_patch_kickstart_area
	;;
    list)         list_upgrade_patch_kickstart_area
	;;
    remove)       remove_upgrade_patch_kickstart_area
	;;
    \?)           :
        ;;
esac

cd ${SCRIPTHOME}
#$RM -rf ${TEM_DIR}

exit 0
